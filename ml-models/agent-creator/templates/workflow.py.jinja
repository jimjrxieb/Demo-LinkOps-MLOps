#!/usr/bin/env python3
"""
{{ agent_name }} Workflow Agent
==============================

{{ description }}

Generated by Agent Creator
Security Level: {{ security_level }}
"""

import asyncio
import json
import logging
import time
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

# Configure logging
logging.basicConfig(
    level=getattr(logging, "{{ logging_level }}"),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class WorkflowStatus(Enum):
    """Workflow execution status."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class {{ agent_name }}WorkflowAgent:
    """
    {{ agent_name }} - Workflow Orchestration Agent
    
    {{ description }}
    
    Tools: {{ tools_str }}
    Capabilities: {{ capabilities_str }}
    Security Level: {{ security_level }}
    """
    
    def __init__(self):
        """Initialize the workflow agent."""
        self.name = "{{ agent_name }}"
        self.agent_type = "workflow"
        self.tools = {{ tools }}
        self.capabilities = {{ capabilities }}
        self.security_level = "{{ security_level }}"
        self.description = "{{ description }}"
        
        # Security configuration
        self.input_validation = {{ input_validation }}
        self.output_sanitization = {{ output_sanitization }}
        self.timeout_seconds = {{ timeout_seconds }}
        self.max_retries = {{ max_retries }}
        
        # State tracking
        self.execution_count = 0
        self.last_execution = None
        self.error_count = 0
        self.workflow_history = []
        
        # Workflow configuration
        self.workflow_steps = {{ workflow_steps }}
        self.triggers = {{ triggers }}
        self.error_handling = "{{ error_handling }}"
        
        # Workflow state
        self.current_workflow = None
        self.workflow_status = WorkflowStatus.PENDING
        self.step_results = {}
        
        logger.info(f"ðŸ¤– {self.name} workflow agent initialized")
        logger.info(f"   Workflow steps: {len(self.workflow_steps)}")
        logger.info(f"   Triggers: {len(self.triggers)}")
        logger.info(f"   Error handling: {self.error_handling}")
    
    def handle(self, workflow_input: str, **kwargs) -> Dict[str, Any]:
        """
        Handle workflow execution.
        
        Args:
            workflow_input: Workflow input or trigger
            **kwargs: Additional parameters
            
        Returns:
            Dictionary with workflow results and metadata
        """
        start_time = time.time()
        self.execution_count += 1
        self.last_execution = datetime.now()
        
        logger.info(f"ðŸ”„ Starting workflow execution: {workflow_input[:50]}...")
        
        try:
            # Input validation
            if self.input_validation:
                validated_input = self._validate_input(workflow_input)
            else:
                validated_input = workflow_input
            
            # Check if workflow should be triggered
            if not self._should_trigger(validated_input):
                return {
                    "success": False,
                    "message": f"Workflow not triggered by input: {validated_input}",
                    "agent_name": self.name,
                    "agent_type": self.agent_type,
                    "execution_time": time.time() - start_time,
                    "timestamp": datetime.now().isoformat(),
                    "execution_count": self.execution_count
                }
            
            # Execute workflow
            result = self._execute_workflow(validated_input, **kwargs)
            
            # Store workflow result
            workflow_result = {
                "input": validated_input,
                "result": result,
                "timestamp": datetime.now().isoformat(),
                "execution_time": time.time() - start_time,
                "success": True,
                "steps_completed": len(result.get("completed_steps", [])),
                "steps_failed": len(result.get("failed_steps", []))
            }
            self.workflow_history.append(workflow_result)
            
            # Output sanitization
            if self.output_sanitization:
                result = self._sanitize_output(result)
            
            # Prepare response
            response = {
                "success": True,
                "input": workflow_input,
                "result": result,
                "agent_name": self.name,
                "agent_type": self.agent_type,
                "execution_time": time.time() - start_time,
                "timestamp": datetime.now().isoformat(),
                "execution_count": self.execution_count,
                "workflow_status": self.workflow_status.value
            }
            
            logger.info(f"âœ… Workflow completed in {response['execution_time']:.2f}s")
            return response
            
        except Exception as e:
            self.error_count += 1
            error_msg = f"Error executing workflow: {str(e)}"
            logger.error(error_msg)
            
            # Store failed workflow
            failed_result = {
                "input": workflow_input,
                "error": error_msg,
                "timestamp": datetime.now().isoformat(),
                "execution_time": time.time() - start_time,
                "success": False
            }
            self.workflow_history.append(failed_result)
            
            return {
                "success": False,
                "input": workflow_input,
                "error": error_msg,
                "agent_name": self.name,
                "agent_type": self.agent_type,
                "execution_time": time.time() - start_time,
                "timestamp": datetime.now().isoformat(),
                "execution_count": self.execution_count
            }
    
    def _should_trigger(self, input_text: str) -> bool:
        """
        Check if workflow should be triggered by input.
        
        Args:
            input_text: Input text
            
        Returns:
            True if workflow should be triggered
        """
        if not self.triggers:
            return True  # No triggers configured, always execute
        
        input_lower = input_text.lower()
        for trigger in self.triggers:
            if trigger.lower() in input_lower:
                logger.info(f"ðŸŽ¯ Workflow triggered by: {trigger}")
                return True
        
        logger.info(f"â¸ï¸ Workflow not triggered by input")
        return False
    
    def _execute_workflow(self, input_text: str, **kwargs) -> Dict[str, Any]:
        """
        Execute the workflow steps.
        
        Args:
            input_text: Workflow input
            **kwargs: Additional parameters
            
        Returns:
            Workflow execution results
        """
        logger.info(f"ðŸ”„ Executing workflow with {len(self.workflow_steps)} steps")
        
        self.workflow_status = WorkflowStatus.RUNNING
        self.current_workflow = input_text
        
        completed_steps = []
        failed_steps = []
        step_results = {}
        
        try:
            for i, step in enumerate(self.workflow_steps):
                step_name = step.get("step", f"step_{i}")
                step_action = step.get("action", "unknown")
                
                logger.info(f"ðŸ“‹ Executing step {i+1}: {step_name} ({step_action})")
                
                try:
                    # Execute step
                    step_result = self._execute_step(step, input_text, **kwargs)
                    
                    # Store step result
                    step_results[step_name] = {
                        "action": step_action,
                        "result": step_result,
                        "status": "completed",
                        "timestamp": datetime.now().isoformat()
                    }
                    
                    completed_steps.append(step_name)
                    logger.info(f"âœ… Step {step_name} completed successfully")
                    
                except Exception as e:
                    error_msg = f"Step {step_name} failed: {str(e)}"
                    logger.error(error_msg)
                    
                    # Handle step failure based on error handling strategy
                    if self.error_handling == "stop":
                        raise e
                    elif self.error_handling == "skip":
                        logger.warning(f"â­ï¸ Skipping failed step: {step_name}")
                        step_results[step_name] = {
                            "action": step_action,
                            "error": error_msg,
                            "status": "skipped",
                            "timestamp": datetime.now().isoformat()
                        }
                        continue
                    elif self.error_handling == "retry":
                        # Retry logic would go here
                        logger.warning(f"ðŸ”„ Retrying step: {step_name}")
                        # For now, just skip
                        step_results[step_name] = {
                            "action": step_action,
                            "error": error_msg,
                            "status": "failed",
                            "timestamp": datetime.now().isoformat()
                        }
                        failed_steps.append(step_name)
                        continue
                    else:
                        # Default to skip
                        step_results[step_name] = {
                            "action": step_action,
                            "error": error_msg,
                            "status": "skipped",
                            "timestamp": datetime.now().isoformat()
                        }
                        continue
            
            # Update workflow status
            if failed_steps:
                self.workflow_status = WorkflowStatus.FAILED
            else:
                self.workflow_status = WorkflowStatus.COMPLETED
            
            # Store step results
            self.step_results = step_results
            
            return {
                "workflow_name": self.name,
                "input": input_text,
                "completed_steps": completed_steps,
                "failed_steps": failed_steps,
                "step_results": step_results,
                "total_steps": len(self.workflow_steps),
                "success_rate": len(completed_steps) / len(self.workflow_steps),
                "status": self.workflow_status.value
            }
            
        finally:
            self.current_workflow = None
    
    def _execute_step(self, step: Dict[str, Any], input_text: str, **kwargs) -> Any:
        """
        Execute a single workflow step.
        
        Args:
            step: Step configuration
            input_text: Workflow input
            **kwargs: Additional parameters
            
        Returns:
            Step execution result
        """
        step_name = step.get("step", "unknown")
        step_action = step.get("action", "unknown")
        step_params = step.get("params", {})
        
        logger.info(f"ðŸ”§ Executing step action: {step_action}")
        
        # Execute based on action type
        if step_action == "read_data":
            return self._execute_read_data(step_params, input_text)
        elif step_action == "process_data":
            return self._execute_process_data(step_params, input_text)
        elif step_action == "validate":
            return self._execute_validate(step_params, input_text)
        elif step_action == "transform":
            return self._execute_transform(step_params, input_text)
        elif step_action == "save":
            return self._execute_save(step_params, input_text)
        elif step_action == "notify":
            return self._execute_notify(step_params, input_text)
        else:
            # Generic step execution
            return self._execute_generic_step(step_action, step_params, input_text)
    
    def _execute_read_data(self, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute read data step."""
        logger.info("ðŸ“– Executing read data step")
        
        # Simulate data reading
        result = {
            "action": "read_data",
            "data_source": params.get("source", "unknown"),
            "records_read": 1000,
            "file_size": "2.5MB",
            "format": params.get("format", "csv"),
            "status": "success"
        }
        
        return result
    
    def _execute_process_data(self, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute process data step."""
        logger.info("âš™ï¸ Executing process data step")
        
        # Simulate data processing
        result = {
            "action": "process_data",
            "records_processed": 1000,
            "processing_time": 2.5,
            "transformations_applied": params.get("transformations", []),
            "status": "success"
        }
        
        return result
    
    def _execute_validate(self, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute validation step."""
        logger.info("âœ… Executing validation step")
        
        # Simulate validation
        result = {
            "action": "validate",
            "validation_rules": params.get("rules", []),
            "records_validated": 1000,
            "validation_errors": 0,
            "status": "success"
        }
        
        return result
    
    def _execute_transform(self, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute transform step."""
        logger.info("ðŸ”„ Executing transform step")
        
        # Simulate transformation
        result = {
            "action": "transform",
            "transformations": params.get("transformations", []),
            "records_transformed": 1000,
            "transformation_time": 1.5,
            "status": "success"
        }
        
        return result
    
    def _execute_save(self, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute save step."""
        logger.info("ðŸ’¾ Executing save step")
        
        # Simulate saving
        result = {
            "action": "save",
            "destination": params.get("destination", "output.csv"),
            "records_saved": 1000,
            "file_size": "1.8MB",
            "status": "success"
        }
        
        return result
    
    def _execute_notify(self, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute notify step."""
        logger.info("ðŸ“¢ Executing notify step")
        
        # Simulate notification
        result = {
            "action": "notify",
            "recipients": params.get("recipients", []),
            "message": params.get("message", "Workflow completed successfully"),
            "notification_sent": True,
            "status": "success"
        }
        
        return result
    
    def _execute_generic_step(self, action: str, params: Dict[str, Any], input_text: str) -> Dict[str, Any]:
        """Execute generic step."""
        logger.info(f"ðŸ”§ Executing generic step: {action}")
        
        # Generic step execution
        result = {
            "action": action,
            "parameters": params,
            "input": input_text,
            "execution_time": 0.5,
            "status": "success"
        }
        
        return result
    
    def _validate_input(self, input_text: str) -> str:
        """
        Validate workflow input.
        
        Args:
            input_text: Input to validate
            
        Returns:
            Validated input
            
        Raises:
            ValueError: If input is invalid
        """
        if not input_text or not input_text.strip():
            raise ValueError("Workflow input cannot be empty")
        
        # Basic security checks
        dangerous_patterns = [
            "<script>", "</script>", "javascript:", "data:text/html",
            "vbscript:", "onload=", "onerror=", "eval(", "exec("
        ]
        
        input_lower = input_text.lower()
        for pattern in dangerous_patterns:
            if pattern in input_lower:
                raise ValueError(f"Dangerous pattern detected: {pattern}")
        
        return input_text.strip()
    
    def _sanitize_output(self, output: Any) -> Any:
        """
        Sanitize output for security.
        
        Args:
            output: Output to sanitize
            
        Returns:
            Sanitized output
        """
        if isinstance(output, dict):
            sanitized = {}
            for key, value in output.items():
                if isinstance(value, str):
                    # Remove potential script tags and dangerous content
                    dangerous_content = [
                        "<script>", "</script>", "javascript:", "data:text/html",
                        "vbscript:", "onload=", "onerror="
                    ]
                    
                    sanitized_value = value
                    for content in dangerous_content:
                        sanitized_value = sanitized_value.replace(content, "")
                    
                    sanitized[key] = sanitized_value
                else:
                    sanitized[key] = value
            
            return sanitized
        
        return output
    
    def get_workflow_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recent workflow history.
        
        Args:
            limit: Maximum number of workflows to return
            
        Returns:
            List of recent workflow results
        """
        return self.workflow_history[-limit:]
    
    def get_workflow_status(self) -> str:
        """Get current workflow status."""
        return self.workflow_status.value
    
    def get_step_results(self) -> Dict[str, Any]:
        """Get results from the last workflow execution."""
        return self.step_results.copy()
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get workflow agent status information.
        
        Returns:
            Dictionary with status information
        """
        return {
            "name": self.name,
            "type": self.agent_type,
            "description": self.description,
            "security_level": self.security_level,
            "tools_count": len(self.tools),
            "capabilities_count": len(self.capabilities),
            "execution_count": self.execution_count,
            "error_count": self.error_count,
            "workflows_executed": len(self.workflow_history),
            "current_workflow": self.current_workflow,
            "workflow_status": self.workflow_status.value,
            "workflow_steps": len(self.workflow_steps),
            "triggers": self.triggers,
            "error_handling": self.error_handling,
            "last_execution": self.last_execution.isoformat() if self.last_execution else None,
            "status": "healthy" if self.error_count < 10 else "degraded"
        }

def main():
    """Demo function to test the workflow agent."""
    print("ðŸ¤– {{ agent_name }} Workflow Agent Demo")
    print("=" * 40)
    
    # Create workflow agent instance
    workflow_agent = {{ agent_name }}WorkflowAgent()
    
    # Test workflow execution
    test_inputs = [
        "manual",
        "schedule",
        "event",
        "data pipeline trigger"
    ]
    
    for input_text in test_inputs:
        print(f"\nðŸ”„ Trigger: {input_text}")
        result = workflow_agent.handle(input_text)
        if result["success"]:
            print(f"ðŸ“¤ Result: {result['result']['status']}")
            print(f"â±ï¸  Time: {result['execution_time']:.3f}s")
            print(f"ðŸ“‹ Steps: {result['result']['completed_steps']}")
        else:
            print(f"âŒ Error: {result.get('error', 'Unknown error')}")
    
    # Show status and history
    print(f"\nðŸ“Š Workflow Agent Status:")
    status = workflow_agent.get_status()
    for key, value in status.items():
        print(f"   {key}: {value}")
    
    print(f"\nðŸ”„ Recent Workflow History:")
    history = workflow_agent.get_workflow_history(3)
    for i, workflow in enumerate(history, 1):
        print(f"   {i}. {workflow['input']} - {'âœ…' if workflow['success'] else 'âŒ'}")
    
    return workflow_agent

if __name__ == "__main__":
    workflow_agent = main() 