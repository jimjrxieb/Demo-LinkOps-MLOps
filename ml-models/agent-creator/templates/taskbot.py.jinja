#!/usr/bin/env python3
"""
{{ agent_name }} TaskBot
======================

{{ description }}

Generated by Agent Creator
Security Level: {{ security_level }}
"""

import json
import logging
import os
import time
from datetime import datetime
from typing import Any, Dict, List, Optional

# Configure logging
logging.basicConfig(
    level=getattr(logging, "{{ logging_level }}"),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class {{ agent_name }}TaskBot:
    """
    {{ agent_name }} - Task-Oriented Agent
    
    {{ description }}
    
    Tools: {{ tools_str }}
    Capabilities: {{ capabilities_str }}
    Security Level: {{ security_level }}
    """
    
    def __init__(self):
        """Initialize the taskbot."""
        self.name = "{{ agent_name }}"
        self.agent_type = "taskbot"
        self.tools = {{ tools }}
        self.capabilities = {{ capabilities }}
        self.security_level = "{{ security_level }}"
        self.description = "{{ description }}"
        
        # Security configuration
        self.input_validation = {{ input_validation }}
        self.output_sanitization = {{ output_sanitization }}
        self.timeout_seconds = {{ timeout_seconds }}
        self.max_retries = {{ max_retries }}
        
        # State tracking
        self.execution_count = 0
        self.last_execution = None
        self.error_count = 0
        self.task_history = []
        
        # Task processing state
        self.current_task = None
        self.task_results = {}
        
        logger.info(f"🤖 {self.name} taskbot initialized")
        logger.info(f"   Tools: {len(self.tools)} configured")
        logger.info(f"   Capabilities: {len(self.capabilities)} configured")
    
    def handle(self, task: str, **kwargs) -> Dict[str, Any]:
        """
        Handle a task and return results.
        
        Args:
            task: Task description or command
            **kwargs: Additional task parameters
            
        Returns:
            Dictionary with task results and metadata
        """
        start_time = time.time()
        self.execution_count += 1
        self.last_execution = datetime.now()
        
        logger.info(f"📋 Processing task: {task[:50]}...")
        
        try:
            # Input validation
            if self.input_validation:
                validated_task = self._validate_input(task)
            else:
                validated_task = task
            
            # Set current task
            self.current_task = validated_task
            
            # Process the task
            result = self._process_task(validated_task, **kwargs)
            
            # Store task result
            task_result = {
                "task": validated_task,
                "result": result,
                "timestamp": datetime.now().isoformat(),
                "execution_time": time.time() - start_time,
                "success": True
            }
            self.task_history.append(task_result)
            self.task_results[validated_task] = result
            
            # Output sanitization
            if self.output_sanitization:
                result = self._sanitize_output(result)
            
            # Prepare response
            response = {
                "success": True,
                "task": task,
                "result": result,
                "agent_name": self.name,
                "agent_type": self.agent_type,
                "execution_time": time.time() - start_time,
                "timestamp": datetime.now().isoformat(),
                "execution_count": self.execution_count,
                "tools_used": self._get_tools_used(validated_task)
            }
            
            logger.info(f"✅ Task completed in {response['execution_time']:.2f}s")
            return response
            
        except Exception as e:
            self.error_count += 1
            error_msg = f"Error processing task: {str(e)}"
            logger.error(error_msg)
            
            # Store failed task
            failed_result = {
                "task": task,
                "error": error_msg,
                "timestamp": datetime.now().isoformat(),
                "execution_time": time.time() - start_time,
                "success": False
            }
            self.task_history.append(failed_result)
            
            return {
                "success": False,
                "task": task,
                "error": error_msg,
                "agent_name": self.name,
                "agent_type": self.agent_type,
                "execution_time": time.time() - start_time,
                "timestamp": datetime.now().isoformat(),
                "execution_count": self.execution_count
            }
        finally:
            self.current_task = None
    
    def _process_task(self, task: str, **kwargs) -> Any:
        """
        Process a task using available tools and capabilities.
        
        Args:
            task: Task to process
            **kwargs: Additional parameters
            
        Returns:
            Task processing result
        """
        logger.info(f"🔧 Processing task with {len(self.tools)} tools")
        
        # Analyze task to determine required tools
        required_tools = self._analyze_task_requirements(task)
        logger.info(f"   Required tools: {required_tools}")
        
        # Check if we have the required tools
        missing_tools = [tool for tool in required_tools if tool not in self.tools]
        if missing_tools:
            logger.warning(f"⚠️ Missing tools: {missing_tools}")
            return f"Task requires tools not available: {missing_tools}"
        
        # Execute task based on capabilities
        if "data_processing" in self.capabilities:
            return self._process_data_task(task, **kwargs)
        elif "file_operations" in self.capabilities:
            return self._process_file_task(task, **kwargs)
        elif "network_requests" in self.capabilities:
            return self._process_network_task(task, **kwargs)
        else:
            return self._process_generic_task(task, **kwargs)
    
    def _analyze_task_requirements(self, task: str) -> List[str]:
        """
        Analyze task to determine required tools.
        
        Args:
            task: Task description
            
        Returns:
            List of required tools
        """
        task_lower = task.lower()
        required_tools = []
        
        # Data processing tools
        if any(word in task_lower for word in ["data", "csv", "json", "process", "analyze"]):
            if "pandas" in self.tools:
                required_tools.append("pandas")
            if "numpy" in self.tools:
                required_tools.append("numpy")
        
        # File operations
        if any(word in task_lower for word in ["file", "read", "write", "save", "load"]):
            if "os" in self.tools:
                required_tools.append("os")
            if "pathlib" in self.tools:
                required_tools.append("pathlib")
        
        # Network requests
        if any(word in task_lower for word in ["http", "api", "request", "fetch", "download"]):
            if "requests" in self.tools:
                required_tools.append("requests")
        
        # Logging
        if "logging" in self.tools:
            required_tools.append("logging")
        
        return required_tools
    
    def _process_data_task(self, task: str, **kwargs) -> Any:
        """Process data-related tasks."""
        logger.info("📊 Processing data task")
        
        try:
            # Simulate data processing
            if "pandas" in self.tools:
                import pandas as pd
                logger.info("   Using pandas for data processing")
            
            if "numpy" in self.tools:
                import numpy as np
                logger.info("   Using numpy for numerical operations")
            
            # Mock data processing result
            result = {
                "task_type": "data_processing",
                "tools_used": ["pandas", "numpy"],
                "data_points_processed": 1000,
                "processing_time": 0.5,
                "result": f"Data processing completed for: {task}"
            }
            
            return result
            
        except ImportError as e:
            logger.error(f"   Import error: {e}")
            return f"Required data processing tools not available: {e}"
    
    def _process_file_task(self, task: str, **kwargs) -> Any:
        """Process file-related tasks."""
        logger.info("📁 Processing file task")
        
        try:
            # Simulate file operations
            if "os" in self.tools:
                import os
                logger.info("   Using os for file operations")
            
            if "pathlib" in self.tools:
                from pathlib import Path
                logger.info("   Using pathlib for path operations")
            
            # Mock file operation result
            result = {
                "task_type": "file_operation",
                "tools_used": ["os", "pathlib"],
                "files_processed": 5,
                "operation_time": 0.2,
                "result": f"File operation completed for: {task}"
            }
            
            return result
            
        except ImportError as e:
            logger.error(f"   Import error: {e}")
            return f"Required file operation tools not available: {e}"
    
    def _process_network_task(self, task: str, **kwargs) -> Any:
        """Process network-related tasks."""
        logger.info("🌐 Processing network task")
        
        try:
            # Simulate network requests
            if "requests" in self.tools:
                import requests
                logger.info("   Using requests for network operations")
            
            # Mock network operation result
            result = {
                "task_type": "network_request",
                "tools_used": ["requests"],
                "requests_made": 3,
                "response_time": 1.2,
                "result": f"Network operation completed for: {task}"
            }
            
            return result
            
        except ImportError as e:
            logger.error(f"   Import error: {e}")
            return f"Required network tools not available: {e}"
    
    def _process_generic_task(self, task: str, **kwargs) -> Any:
        """Process generic tasks."""
        logger.info("🔧 Processing generic task")
        
        # Generic task processing
        result = {
            "task_type": "generic",
            "tools_used": self.tools[:3],  # Use first 3 tools
            "processing_time": 0.1,
            "result": f"Generic task completed for: {task}"
        }
        
        return result
    
    def _get_tools_used(self, task: str) -> List[str]:
        """Get list of tools used for a specific task."""
        return self._analyze_task_requirements(task)
    
    def _validate_input(self, task: str) -> str:
        """
        Validate task input.
        
        Args:
            task: Task to validate
            
        Returns:
            Validated task
            
        Raises:
            ValueError: If task is invalid
        """
        if not task or not task.strip():
            raise ValueError("Task cannot be empty")
        
        # Security checks for task content
        dangerous_patterns = [
            "rm -rf", "del /s", "format", "shutdown", "reboot",
            "kill -9", "sudo", "eval(", "exec(", "__import__"
        ]
        
        task_lower = task.lower()
        for pattern in dangerous_patterns:
            if pattern in task_lower:
                raise ValueError(f"Dangerous pattern detected in task: {pattern}")
        
        return task.strip()
    
    def _sanitize_output(self, output: Any) -> Any:
        """
        Sanitize output for security.
        
        Args:
            output: Output to sanitize
            
        Returns:
            Sanitized output
        """
        if isinstance(output, str):
            # Remove potential script tags and dangerous content
            dangerous_content = [
                "<script>", "</script>", "javascript:", "data:text/html",
                "vbscript:", "onload=", "onerror="
            ]
            
            sanitized = output
            for content in dangerous_content:
                sanitized = sanitized.replace(content, "")
            
            return sanitized
        
        return output
    
    def get_task_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recent task history.
        
        Args:
            limit: Maximum number of tasks to return
            
        Returns:
            List of recent task results
        """
        return self.task_history[-limit:]
    
    def get_task_result(self, task: str) -> Optional[Any]:
        """
        Get result for a specific task.
        
        Args:
            task: Task description
            
        Returns:
            Task result if found, None otherwise
        """
        return self.task_results.get(task)
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get taskbot status information.
        
        Returns:
            Dictionary with status information
        """
        return {
            "name": self.name,
            "type": self.agent_type,
            "description": self.description,
            "security_level": self.security_level,
            "tools_count": len(self.tools),
            "capabilities_count": len(self.capabilities),
            "execution_count": self.execution_count,
            "error_count": self.error_count,
            "tasks_completed": len([t for t in self.task_history if t["success"]]),
            "tasks_failed": len([t for t in self.task_history if not t["success"]]),
            "last_execution": self.last_execution.isoformat() if self.last_execution else None,
            "current_task": self.current_task,
            "status": "healthy" if self.error_count < 10 else "degraded"
        }

def main():
    """Demo function to test the taskbot."""
    print("🤖 {{ agent_name }} TaskBot Demo")
    print("=" * 40)
    
    # Create taskbot instance
    taskbot = {{ agent_name }}TaskBot()
    
    # Test various tasks
    test_tasks = [
        "Process the sales data CSV file",
        "Read configuration from JSON file",
        "Make API request to get weather data",
        "Analyze customer feedback data"
    ]
    
    for task in test_tasks:
        print(f"\n📋 Task: {task}")
        result = taskbot.handle(task)
        print(f"📤 Result: {result['result']}")
        print(f"⏱️  Time: {result['execution_time']:.3f}s")
        print(f"🔧 Tools used: {result.get('tools_used', [])}")
    
    # Show status and history
    print(f"\n📊 TaskBot Status:")
    status = taskbot.get_status()
    for key, value in status.items():
        print(f"   {key}: {value}")
    
    print(f"\n📋 Recent Task History:")
    history = taskbot.get_task_history(3)
    for i, task_result in enumerate(history, 1):
        print(f"   {i}. {task_result['task'][:30]}... - {'✅' if task_result['success'] else '❌'}")
    
    return taskbot

if __name__ == "__main__":
    taskbot = main() 