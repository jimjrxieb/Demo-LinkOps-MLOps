#!/usr/bin/env python3
"""
{{ agent_name }} Assistant
=========================

{{ description }}

Generated by Agent Creator
Security Level: {{ security_level }}
"""

import json
import logging
import re
import time
from datetime import datetime
from typing import Any, Dict, List, Optional

# Configure logging
logging.basicConfig(
    level=getattr(logging, "{{ logging_level }}"),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class {{ agent_name }}Assistant:
    """
    {{ agent_name }} - AI Assistant Agent
    
    {{ description }}
    
    Tools: {{ tools_str }}
    Capabilities: {{ capabilities_str }}
    Security Level: {{ security_level }}
    """
    
    def __init__(self):
        """Initialize the assistant."""
        self.name = "{{ agent_name }}"
        self.agent_type = "assistant"
        self.tools = {{ tools }}
        self.capabilities = {{ capabilities }}
        self.security_level = "{{ security_level }}"
        self.description = "{{ description }}"
        
        # Security configuration
        self.input_validation = {{ input_validation }}
        self.output_sanitization = {{ output_sanitization }}
        self.timeout_seconds = {{ timeout_seconds }}
        self.max_retries = {{ max_retries }}
        
        # State tracking
        self.execution_count = 0
        self.last_execution = None
        self.error_count = 0
        self.conversation_history = []
        
        # Assistant state
        self.context = {}
        self.user_preferences = {}
        self.conversation_mode = "helpful"
        
        logger.info(f"ðŸ¤– {self.name} assistant initialized")
        logger.info(f"   Tools: {len(self.tools)} configured")
        logger.info(f"   Capabilities: {len(self.capabilities)} configured")
        logger.info(f"   Conversation mode: {self.conversation_mode}")
    
    def handle(self, message: str, **kwargs) -> Dict[str, Any]:
        """
        Handle a user message and return response.
        
        Args:
            message: User message
            **kwargs: Additional parameters (context, mode, etc.)
            
        Returns:
            Dictionary with assistant response and metadata
        """
        start_time = time.time()
        self.execution_count += 1
        self.last_execution = datetime.now()
        
        logger.info(f"ðŸ’¬ Processing message: {message[:50]}...")
        
        try:
            # Input validation
            if self.input_validation:
                validated_message = self._validate_input(message)
            else:
                validated_message = message
            
            # Update context
            self._update_context(kwargs.get('context', {}))
            
            # Process the message
            response = self._process_message(validated_message, **kwargs)
            
            # Store conversation
            conversation_entry = {
                "user_message": validated_message,
                "assistant_response": response,
                "timestamp": datetime.now().isoformat(),
                "execution_time": time.time() - start_time,
                "context": self.context.copy()
            }
            self.conversation_history.append(conversation_entry)
            
            # Output sanitization
            if self.output_sanitization:
                response = self._sanitize_output(response)
            
            # Prepare response
            result = {
                "success": True,
                "message": message,
                "response": response,
                "agent_name": self.name,
                "agent_type": self.agent_type,
                "execution_time": time.time() - start_time,
                "timestamp": datetime.now().isoformat(),
                "execution_count": self.execution_count,
                "conversation_length": len(self.conversation_history)
            }
            
            logger.info(f"âœ… Message processed in {result['execution_time']:.2f}s")
            return result
            
        except Exception as e:
            self.error_count += 1
            error_msg = f"Error processing message: {str(e)}"
            logger.error(error_msg)
            
            return {
                "success": False,
                "message": message,
                "error": error_msg,
                "agent_name": self.name,
                "agent_type": self.agent_type,
                "execution_time": time.time() - start_time,
                "timestamp": datetime.now().isoformat(),
                "execution_count": self.execution_count
            }
    
    def _process_message(self, message: str, **kwargs) -> str:
        """
        Process a user message and generate response.
        
        Args:
            message: User message
            **kwargs: Additional parameters
            
        Returns:
            Assistant response
        """
        logger.info(f"ðŸ§  Processing message with {len(self.capabilities)} capabilities")
        
        # Analyze message intent
        intent = self._analyze_intent(message)
        logger.info(f"   Detected intent: {intent}")
        
        # Generate response based on intent and capabilities
        if intent == "greeting":
            return self._generate_greeting_response(message)
        elif intent == "question":
            return self._generate_question_response(message)
        elif intent == "request":
            return self._generate_request_response(message)
        elif intent == "conversation":
            return self._generate_conversation_response(message)
        else:
            return self._generate_generic_response(message)
    
    def _analyze_intent(self, message: str) -> str:
        """
        Analyze message intent.
        
        Args:
            message: User message
            
        Returns:
            Detected intent
        """
        message_lower = message.lower()
        
        # Greeting patterns
        greeting_patterns = ["hello", "hi", "hey", "good morning", "good afternoon", "good evening"]
        if any(pattern in message_lower for pattern in greeting_patterns):
            return "greeting"
        
        # Question patterns
        question_patterns = ["what", "how", "why", "when", "where", "who", "which", "?"]
        if any(pattern in message_lower for pattern in question_patterns):
            return "question"
        
        # Request patterns
        request_patterns = ["help", "assist", "support", "please", "can you", "could you"]
        if any(pattern in message_lower for pattern in request_patterns):
            return "request"
        
        # Conversation patterns
        conversation_patterns = ["tell me", "explain", "describe", "talk about"]
        if any(pattern in message_lower for pattern in conversation_patterns):
            return "conversation"
        
        return "general"
    
    def _generate_greeting_response(self, message: str) -> str:
        """Generate greeting response."""
        greetings = [
            f"Hello! I'm {self.name}, your AI assistant. How can I help you today?",
            f"Hi there! I'm {self.name}. What can I assist you with?",
            f"Greetings! I'm {self.name}, ready to help with your questions and tasks.",
            f"Welcome! I'm {self.name}. How may I be of service?"
        ]
        
        import random
        return random.choice(greetings)
    
    def _generate_question_response(self, message: str) -> str:
        """Generate response to questions."""
        # Analyze question type
        message_lower = message.lower()
        
        if "what can you do" in message_lower or "capabilities" in message_lower:
            return self._describe_capabilities()
        elif "tools" in message_lower or "available tools" in message_lower:
            return self._describe_tools()
        elif "help" in message_lower:
            return self._provide_help()
        else:
            return self._generate_informative_response(message)
    
    def _generate_request_response(self, message: str) -> str:
        """Generate response to requests."""
        message_lower = message.lower()
        
        if "search" in message_lower and "search" in self.tools:
            return "I can help you search for information. What would you like me to search for?"
        elif "calculate" in message_lower and "calculate" in self.tools:
            return "I can help you with calculations. What would you like me to calculate?"
        elif "format" in message_lower and "format" in self.tools:
            return "I can help you format text or data. What would you like me to format?"
        else:
            return "I understand you're making a request. Let me help you with that. Could you provide more details?"
    
    def _generate_conversation_response(self, message: str) -> str:
        """Generate conversational response."""
        return f"I'd be happy to discuss that with you! Based on your message about '{message[:30]}...', I can provide information and insights. What specific aspect would you like to explore?"
    
    def _generate_generic_response(self, message: str) -> str:
        """Generate generic response."""
        return f"I received your message: '{message}'. I'm here to help with various tasks and questions. How can I assist you?"
    
    def _describe_capabilities(self) -> str:
        """Describe assistant capabilities."""
        if not self.capabilities:
            return f"I'm {self.name}, a basic AI assistant. I can help with general questions and tasks."
        
        capabilities_text = ", ".join(self.capabilities)
        return f"I'm {self.name}, an AI assistant with the following capabilities: {capabilities_text}. How can I help you?"
    
    def _describe_tools(self) -> str:
        """Describe available tools."""
        if not self.tools:
            return "I don't have any specific tools configured, but I can still help with general questions and tasks."
        
        tools_text = ", ".join(self.tools)
        return f"I have access to these tools: {tools_text}. How would you like me to use them to help you?"
    
    def _provide_help(self) -> str:
        """Provide help information."""
        help_text = f"""
I'm {self.name}, your AI assistant. Here's how I can help you:

**What I can do:**
- Answer questions and provide information
- Help with tasks and requests
- Engage in conversation
- Use available tools to assist you

**Available tools:** {', '.join(self.tools) if self.tools else 'None configured'}

**Capabilities:** {', '.join(self.capabilities) if self.capabilities else 'General assistance'}

Just ask me anything or tell me what you need help with!
        """.strip()
        
        return help_text
    
    def _generate_informative_response(self, message: str) -> str:
        """Generate informative response to questions."""
        # Simple keyword-based responses
        message_lower = message.lower()
        
        if "weather" in message_lower:
            return "I can help you with weather information, but I don't have real-time weather data access. You might want to check a weather service or app."
        
        elif "time" in message_lower:
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            return f"The current time is {current_time}."
        
        elif "date" in message_lower:
            current_date = datetime.now().strftime("%A, %B %d, %Y")
            return f"Today is {current_date}."
        
        elif "name" in message_lower:
            return f"My name is {self.name}. I'm an AI assistant designed to help you with various tasks and questions."
        
        else:
            return f"That's an interesting question about '{message[:30]}...'. I'd be happy to help you find information about that topic."
    
    def _update_context(self, context: Dict[str, Any]):
        """Update conversation context."""
        self.context.update(context)
        logger.debug(f"Updated context: {self.context}")
    
    def _validate_input(self, message: str) -> str:
        """
        Validate user message.
        
        Args:
            message: Message to validate
            
        Returns:
            Validated message
            
        Raises:
            ValueError: If message is invalid
        """
        if not message or not message.strip():
            raise ValueError("Message cannot be empty")
        
        # Basic security checks
        dangerous_patterns = [
            "<script>", "</script>", "javascript:", "data:text/html",
            "vbscript:", "onload=", "onerror=", "eval(", "exec("
        ]
        
        message_lower = message.lower()
        for pattern in dangerous_patterns:
            if pattern in message_lower:
                raise ValueError(f"Dangerous pattern detected: {pattern}")
        
        return message.strip()
    
    def _sanitize_output(self, output: Any) -> Any:
        """
        Sanitize output for security.
        
        Args:
            output: Output to sanitize
            
        Returns:
            Sanitized output
        """
        if isinstance(output, str):
            # Remove potential script tags and dangerous content
            dangerous_content = [
                "<script>", "</script>", "javascript:", "data:text/html",
                "vbscript:", "onload=", "onerror="
            ]
            
            sanitized = output
            for content in dangerous_content:
                sanitized = sanitized.replace(content, "")
            
            return sanitized
        
        return output
    
    def get_conversation_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recent conversation history.
        
        Args:
            limit: Maximum number of conversations to return
            
        Returns:
            List of recent conversations
        """
        return self.conversation_history[-limit:]
    
    def set_conversation_mode(self, mode: str):
        """
        Set conversation mode.
        
        Args:
            mode: Conversation mode (helpful, professional, casual, etc.)
        """
        self.conversation_mode = mode
        logger.info(f"ðŸ’¬ Conversation mode set to: {mode}")
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get assistant status information.
        
        Returns:
            Dictionary with status information
        """
        return {
            "name": self.name,
            "type": self.agent_type,
            "description": self.description,
            "security_level": self.security_level,
            "tools_count": len(self.tools),
            "capabilities_count": len(self.capabilities),
            "execution_count": self.execution_count,
            "error_count": self.error_count,
            "conversations_handled": len(self.conversation_history),
            "conversation_mode": self.conversation_mode,
            "last_execution": self.last_execution.isoformat() if self.last_execution else None,
            "status": "healthy" if self.error_count < 10 else "degraded"
        }

def main():
    """Demo function to test the assistant."""
    print("ðŸ¤– {{ agent_name }} Assistant Demo")
    print("=" * 40)
    
    # Create assistant instance
    assistant = {{ agent_name }}Assistant()
    
    # Test various messages
    test_messages = [
        "Hello!",
        "What can you do?",
        "Can you help me?",
        "What tools do you have?",
        "Tell me about yourself"
    ]
    
    for message in test_messages:
        print(f"\nðŸ’¬ User: {message}")
        result = assistant.handle(message)
        if result["success"]:
            print(f"ðŸ¤– Assistant: {result['response']}")
            print(f"â±ï¸  Time: {result['execution_time']:.3f}s")
        else:
            print(f"âŒ Error: {result['error']}")
    
    # Show status and history
    print(f"\nðŸ“Š Assistant Status:")
    status = assistant.get_status()
    for key, value in status.items():
        print(f"   {key}: {value}")
    
    print(f"\nðŸ’¬ Recent Conversation History:")
    history = assistant.get_conversation_history(3)
    for i, conv in enumerate(history, 1):
        print(f"   {i}. User: {conv['user_message'][:30]}...")
        print(f"      Assistant: {conv['assistant_response'][:50]}...")
    
    return assistant

if __name__ == "__main__":
    assistant = main() 