from fastapi import APIRouter, Request, UploadFile, File, Form, Depends, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from core.db.database import get_db
from core.db.models import Orb, Log
import shutil
import os
from datetime import datetime
import uuid
from core.utils.llm import generate_orb_from_text

router = APIRouter()
templates = Jinja2Templates(directory="core/gui/templates")


@router.get("/gui", response_class=HTMLResponse)
def gui_home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})


@router.get("/gui/orbs", response_class=HTMLResponse)
def gui_orbs(request: Request, db: Session = Depends(get_db)):
    orbs = db.query(Orb).order_by(Orb.created_at.desc()).all()
    return templates.TemplateResponse("orbs.html", {"request": request, "orbs": orbs})


@router.get("/gui/logs", response_class=HTMLResponse)
def gui_logs(request: Request, db: Session = Depends(get_db)):
    logs = db.query(Log).order_by(Log.created_at.desc()).limit(20).all()
    return templates.TemplateResponse("logs.html", {"request": request, "logs": logs})


@router.get("/gui/whis", response_class=HTMLResponse)
def gui_whis_form(request: Request):
    return templates.TemplateResponse("whis.html", {"request": request})


@router.post("/gui/whis", response_class=HTMLResponse)
def gui_whis_upload(request: Request, file: UploadFile = File(...), task_id: str = Form(...), db: Session = Depends(get_db)):
    # Validate file type
    if not file.content_type.startswith('image/'):
        return templates.TemplateResponse("whis.html", {
            "request": request,
            "error": "Invalid file type. Please upload an image file."
        })
    
    # Create screenshots directory if it doesn't exist
    os.makedirs("screenshots", exist_ok=True)
    
    # Save uploaded file
    upload_path = f"screenshots/{file.filename}"
    try:
        with open(upload_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    except Exception as e:
        return templates.TemplateResponse("whis.html", {
            "request": request,
            "error": f"Failed to save file: {str(e)}"
        })
    
    # Try to extract text using OCR
    extracted_text = ""
    try:
        from PIL import Image
        import pytesseract
        
        image = Image.open(upload_path)
        extracted_text = pytesseract.image_to_string(image)
    except ImportError:
        extracted_text = "OCR not available - Tesseract not installed"
    except Exception as e:
        extracted_text = f"OCR failed: {str(e)}"
    
    # Create log entry
    try:
        log_entry = Log(
            id=str(uuid.uuid4()),
            agent="katie",
            task_id=task_id,
            action=f"Uploaded screenshot: {file.filename}",
            result=extracted_text,
            created_at=datetime.utcnow()
        )
        db.add(log_entry)
        db.commit()
    except Exception as e:
        # Log creation failed, but don't fail the upload
        pass
    
    return templates.TemplateResponse("whis.html", {
        "request": request,
        "status": "Uploaded",
        "task_id": task_id,
        "path": upload_path,
        "time": datetime.utcnow(),
        "extracted_text": extracted_text[:500] + "..." if len(extracted_text) > 500 else extracted_text
    })


@router.post("/gui/create-orb", response_class=HTMLResponse)
def gui_create_orb(request: Request, log_id: str = Form(...), db: Session = Depends(get_db)):
    # Find the log entry
    log_entry = db.query(Log).filter(Log.id == log_id).first()
    if not log_entry:
        raise HTTPException(status_code=404, detail="Log not found")
    
    # Create orb from log
    orb = Orb(
        id=str(uuid.uuid4()),
        name=f"Auto-Orb: {log_entry.task_id}",
        description=log_entry.result[:480] if log_entry.result else "No content extracted",
        category="AutoGenerated",
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow()
    )
    
    db.add(orb)
    db.commit()
    db.refresh(orb)
    
    return RedirectResponse(url="/gui/orbs", status_code=303)


@router.get("/gui/james", response_class=HTMLResponse)
def gui_james(request: Request, q: str = "", db: Session = Depends(get_db)):
    try:
        query = db.query(Orb)
        if q:
            query = query.filter(
                Orb.name.ilike(f"%{q}%") |
                Orb.description.ilike(f"%{q}%") |
                Orb.category.ilike(f"%{q}%")
            )
        results = query.order_by(Orb.updated_at.desc()).limit(10).all()
    except Exception as e:
        # Handle database connection errors gracefully
        results = []
    
    return templates.TemplateResponse("james.html", {"request": request, "results": results, "query": q})


@router.post("/gui/whis/text", response_class=HTMLResponse)
def gui_whis_text(
    request: Request,
    task_id: str = Form(...),
    text: str = Form(...),
    db: Session = Depends(get_db)
):
    from core.db.models import Log, Orb
    from core.utils.llm import generate_orb_from_text

    log = Log(agent="katie", task_id=task_id, action="Text dump", result=text)
    db.add(log)
    db.commit()

    orb_data = generate_orb_from_text(task_id, text)
    if "error" not in orb_data:
        new_orb = Orb(**orb_data)
        db.add(new_orb)
        db.commit()
        status = "Text logged + Orb generated ðŸŽ‰"
    else:
        status = f"Text logged, but Orb failed: {orb_data['error']}"

    return templates.TemplateResponse("whis.html", {
        "request": request,
        "status": status,
        "task_id": task_id
    })
